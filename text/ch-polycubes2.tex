\chapter{\label{ch:polycubes2}Designing polycube assembly rules}

\minitoc

In the previous chapter, we saw how to map an input rule into an output polycube shape. However, the reverse problem is just as significant; given a target shape, how do you find a rule that assembles it?  

% Fully addressable is the easy solution.

A trivial solution would be to use \emph{fully addressable assembly}: simply assign a unique species to each cube and a unique colour to each pair of adjacent patches. This is similar to what was done for DNA bricks (Section~\ref{sec:dna_tiles_bricks}), where every brick tile is unique. However, as was seen in Chapter~\ref{ch:polycubes1}, many shapes have alternative solutions requiring significantly fewer unique components. See Figure~\ref{fig:addressable}, where a square tetromino is shown to have a variety of inputs assembling it, from the minimal solution with just a single species and one colour, up to the fully addressable solution with four species and four colours (\(\widetilde{K}_s = \widetilde{K}_c = 4\)). The intermediate solutions are not necessarily deterministic in terms of which position gets which species, but they will always assemble into the same shape.

Meanwhile, the empty red region in Figure~\ref{fig:addressable}.b) shows combinations of \(\widetilde{K}_s\) and \(\widetilde{K}_c\) for which a solution is not possible. For example, if you use a single species, you cannot use more than one colour.

\begin{figure}[h]
    \centering
    \begin{overpic}[width=\textwidth]{figures/solve/adressable.eps}
        \put(-10,480){a)}
        \put(360,580){b)}

        \put(370, 350){\makebox(0,0){\rotatebox{90}{Number of colours (\(\widetilde{K}_c\))}}}
        \put(600,-30){Number of species (\(\widetilde{K}_s\))}
    \end{overpic}
    \vspace{1em}
    %\includesvg[width=\textwidth, inkscapelatex=false]{figures/solve/adressable.svg}
    \caption{\(2 \times 2\) square polyomino assembled with different levels of complexity. \textbf{a)} Scematic of the input shape, consisting of four connected tiles. \textbf{b)} The green region shows possible assembly solutions, from the \emph{minimal solution} using a single species and a single colour (bottom left), to the \emph{fully addressable solution} using four species and colours (top right). The red region lacks solutions. }
    \label{fig:addressable}
\end{figure}

So, how do we find these alternative and simpler input rules for a shape? Surely, there must exist a better method than sampling the space of all rules (as done in Chapter~\ref{ch:polycubes1})? This chapter presents an approach where \emph{satisfiability solving} is used to determine if a shape can be assembled from a given number of colours and species, thus automatically filling in solution landscapes such as the one shown in Figure~\ref{fig:addressable}. Furthermore, a complementary approach of substituting similar species is also described, in Section~\ref{sec:substitution_solving}.


\section{Satisfiability solving}

Building upon a method for determining patchy particle interactions for unbounded structures \cite{romano2020designing}, it is possible to formulate and solve satisfiability problems for the bounded polycube structures.

In essence, we formulate a boolean expression that, if true, means it is possible to assemble a given polycube topology using a given number of colours and species. We can then use a satisfiability solver to check if that expression is indeed solvable and, if it is, extract an assembly rule from the solution.

\subsection{Boolean expressions}

The boolean expression is written in conjunctive normal form (CNF), where variables are composed into clauses using \emph{NOT} (\(\lnot\)) and \emph{OR} (\(\lor\)) operators and where the clauses are joined by \emph{AND} (\(\land\)) operators. As a simple example, see the expression below:

\[
    (\lnot x_{rain} \lor x_{umbrella} \lor  \lnot x_{walk}) \land
    (\lnot x_{rainbow} \lor x_{rain}) \land
    (\lnot x_{rainbow} \lor x_{sunny})
\]

The first clause is \({true}\) for all values except when \(x_{rain}={true}\), \(x_{umbrella}={false}\) and \(x_{walk}=true\); so the solution of taking a walk in the rain without an umbrella is forbidden (allthough I would personally prefer a good coat). This could also be written as an \emph{implication}: \(x_{rain} \land x_{walk} \implies x_{umbrella}\).

The following two clauses in the example above are the CNF form of another implication: \(x_{rainbow} \implies  x_{rain} \land x_{sunshine}\), stating that a rainbow implies that we have both rain and sunshine (we cannot have a rainbow without rain or without sunshine). The full expression is satisfiable, for example, if we set \(x_{sun}=true\), \(x_{rain}=false\), \(x_{walk}=false\), \(x_{umbrella}=false\), and \(x_{rainbow}=false\); ignoring the sunshine walk and remaining inside to work.

\subsection{Polycube formulation}

For the polycube problem, we introduce the following variables:
\begin{description}
    \item[\(x_{l,p,o}^{A}\)] (patch \(p\) at position \(l\) has orientation \(o\))
    \item[\(x_{c_i,c_j}^{B}\)] (colour \(c_i\) is compatible with colour \(c_j\))
    \item[\(x_{s,p,c}^{C}\)] (patch \(p\) on species \(s\) has colour \(c\))
    \item[\(x_{p_1,o_1,p_2,o_2}^{D}\)] (patch \(p_1\) with orientation \(o_1\) binds to patch \(p_2\) with orientation \(o_2\))
    \item[\(x_{l,p,c}^{F}\)] (patch \(p\) at position \(l\) has colour \(c\))
    \item[\(x_{s,p,o}^{O}\)] (patch \(p\) on species \(s\) has orientation \(o\))
    \item[\(x_{l,s,r}^{P}\)] (position \(l\) is occupied by species \(s\) rotated by \(r\))] 
\end{description}

We then formulate clauses to constrain the problem, seen in Table~\ref{tab:sat_clauses}. Clauses (i)-(vii) are the same as in \cite{romano2020designing} while the remaining are added, together with variables \(x^D\), \(x^A\) and \(x^O\) abpve, to include \emph{torsional restrictions}, meaning that patches need to bind at a compatible orientation (compared to being allowed to rotate freely).

\begin{table}[h!]
    \centering
    \begin{tabular}{|l|l|l|}
        \hline
        & Clause & Boolean expression \\ [0.5ex] 
        \hline
        \hline
        (i) & \(C^{B}_{c_i,c_j,c_k}\) & \(\neg x_{c_i,c_j}^{B} \lor \neg x_{c_i,c_k}^{B}\) \\ % Each colour is compatible with exactly one colour
        (ii) &  \(C^{C}_{s,p,c_k,c_l}\) & \(\neg x_{s, p, c_k}^{C} \lor \neg x_{s, p, c_l}^{C}\) \\ % Each patch is assigned exactly one colour
        (iii) & \(C^{P}_{l, s_i, r_i, s_j, r_j}\)  & \(\neg x_{l,s_i,r_i}^{P} \lor \neg x_{l,s_j,r_j}^{P} \) \\ % Each lattice position is occupied by a single species with one assigned rotation
        (iv) & \(C^{BF}_{l_i,p_i,c_i,l_j,p_j,c_j}\) & \(\left(x_{l_i,p_i,c_i}^{F} \land x_{l_j,p_j,c_j}^{F} \right) \Rightarrow x_{c_i,c_j}^{B}\) \\ % Colours of patches that interact in the target lattice must be compatible
        (v) & \(C^{rotC}_{l,s,r,p,c}\) & \(x_{l,s,r}^{P} \Rightarrow \left(x_{l,p,c}^{F} \Leftrightarrow x_{s, \phi_r(p), c}^{C}\right)\) \\ % The patches at a lattice position is set to have the patch colours of the rotated occupying species.
        (vi) & \(C^{all s}_{s}\)  & \(\bigvee_{\forall l, r} x_{l,s,r}^{P}\) \\ % All \widetilde{K}_s species are used for the lattice assembly
        (vii) & \(C^{all c}_{c}\)  & \(\bigvee_{\forall s, p} x_{s,p,c}^{C}\) \\ % All \widetilde{K}_c patch colours are used in the solution
        (iix) &  \(C^{O}_{s,p,o_k,o_l}\) & \(\neg x_{s, p, o_k}^{O} \lor \neg x_{s, p, o_l}^{O}\) \\ % Each patch is assigned exactly one orientation
        (ix) & \(C^{DA}_{l_i,p_i,c_i,l_j,p_j,c_j}\) & \(\left(x_{l_i,p_i,c_i}^{A} \land x_{l_j,p_j,c_j}^{A} \right) \Rightarrow x_{p_i,c_i,p_j,c_j}^{D}\) \\ % Orientation of patches that interact in the target lattice must be compatible
        (x) & \(C^{rotO}_{l,s,r,p,o}\) & \(x_{l,s,r}^{P} \Rightarrow \left(x_{l,p,o}^{A} \Leftrightarrow x_{s, \phi_r(p), o}^{O}\right)\) \\ % The patches at a lattice position is set to have the orientations of the rotated occupying species.
        
        \hline
    \end{tabular}
    \caption{SAT clauses. (i) Each colour is compatible with \textit{exactly one} colour. (ii) Each patch has \textit{exactly one} colour. (iii) Each lattice position contains a single species with an assigned rotation. (iv) Adjacent patches in the lattice must have compatible colours. (v) Patches at a lattice position are coloured according to the (rotated) occupying species. (vi) All \(\widetilde{K}_s\) species are required in the solution. (vii) All \(\widetilde{K}_c\) patch colours are required in the solution. (iix) Each patch is assigned \textit{exactly one} orientation. (ix) Adjacent patches in the target lattice must have the same orientation. (v)  Patches at a lattice position are oriented according to the (rotated) occupying species.}
    \label{tab:sat_clauses}
    \end{table}

\subsection{On the importance of torsional interactions}

It would certainly be possible to use the solver without any constraints on the patch orientations (as it was done in \cite{romano2020designing}). However, if we wanted to use the stochastic assembler from Chapter~\ref{ch:polycubes1}, orientations would have to be assigned randomly, resulting in a combinatoric explosion of additional assembly paths.

More importantly, the assembly should benefit from torsional patch interaction (for 2D polyominoes, this corresponds to the requirement that tiles can be rotated in the plane but not flipped). Figure~\ref{fig:torsion} shows two versions of a simple rule, the only difference being the orientation of a single patch. While co-operative binding might, in such a case, benefit the desired square assembly, the self-limiting ability would be significantly improved if the patches were torsionally rigid.

\begin{figure}[h]
    \centering
    \begin{overpic}[width=\textwidth]{figures/torsion.png}
        \put(0,470){a)}
        \put(550,500){b)}
    \end{overpic}
    \caption{The consequences of a rotated patch. \textbf{a)} A minimal solution (one species and one colour) for a \(2 \times 2\) square. \textbf{b)} The same rule as a), except one patch on is rotated by \(\frac{\pi}{2}\).}
    \label{fig:torsion}
\end{figure}


\subsection{Bounded structures}
Besides the torsional patches, another important difference to \cite{romano2020designing} is that the method presented here allows for bounded structures. This is achieved by adding species of type ``empty'' as a "shell" around the shape to ensure that empty patches remain unbound. Adding a clause \(x_{0,1}^{B}\) ensures that colour 0 always binds to 1. 

We then add clauses \(x_{l,p,1}^{F}\) to constrain every boundary patch \(p\) at lattice position \(l\) to have the colour \(1\) and thereby not bind anything else. For example, in Figure~\ref{fig:sat_boundary}, where these boundary patches are seen coloured white (and bordering an empty square), we get the following 12 clauses:

\begin{equation}
    \begin{aligned}
        &x_{0,0,1}^{F} \land x_{0,1,1}^{F} \land x_{0,3,1}^{F} \land \\
        &x_{1,0,1}^{F} \land x_{1,2,1}^{F} \land x_{1,3,1}^{F} \land \\
        &x_{3,0,1}^{F} \land x_{3,1,1}^{F} \land x_{3,2,1}^{F} \land \\
        &x_{4,1,1}^{F} \land x_{4,2,1}^{F} \land x_{4,3,1}^{F}
    \end{aligned}
\end{equation}

Note that for 3D polycubes, there are six patches per species instead of the four seen in the 2D polyomino in Figure~\ref{fig:sat_boundary}. This also introduces 27 possible cube rotations, compared to the 4 square rotations defined for 2D.

The topology of the shape is enforced by clause (iv), \(\left(\lnot x_{l_1, p_1, c_1}^{F} \lor \lnot x_{l_2, p_2, c_2}^{F} \lor x_{c_1, c_2}^{B}\right)\) in CNF, making sure that if patch \(p_1\) on lattice position \(l_1\) binds to \(p_2\) on lattice position \(l_2\), their colours are compatible. Similarly, clause (ix) ensures that the patches have the same orientation.

% Figure of topology graph?

\begin{figure}[h]
    \centering\includesvg[width=.5\textwidth, inkscapelatex=false]{figures/sat_boundary.svg}
    \caption{Bounded shape topology for satisfiability solving. Patches at the boundary of the shape (white) are constrained to only bind to ``empty''. 3D shapes are specified the same way, but with six patches per species.}
    \label{fig:sat_boundary}
\end{figure}

\subsection{Interaction matrix}
Compared to \cite{romano2020designing}, the interaction matrix is by default fixed. Thus, the \(x_{c_i,c_j}^{B}\) variable has fixed values and we only need to extract the values of \(x_{l,p,c}^{F}\) and \(x_{s,p,o}^{O}\) to construct the assembly rule. Note, however, that it is still possible to re-enable a variable interaction matrix, something which could prove useful for some shapes where, for example, self-complementary patches would result in a lower complexity.

Compared to the interaction matrix convention used in Chapter~\ref{ch:polycubes1}, where each colour \(c\) binds to \(-c\), the colour values in the SAT solver remain unsigned and instead pair each even colour \(c\) to the odd \(c+1\). The colour pairs are mapped back to the polycube convention when obtaining the solution.

\subsection{Assembly determinism}
Even if the SAT solver determines that a solution exists, it is still possible that the rule we get can also assemble into other shapes. Recall, once more, the ``giraffe duck'' shape from Figure~\ref{fig:UND}.b). If we solved for the shape with two neck cubes, the non-deterministic rule shown would be a perfectly valid solution according to the SAT solver, even though it can also produce giraffe ducks with any other neck length.

Because of this, we once again use the stochastic assembler to verify that the rule assembles into the correct shape every time. Each potential rule is evaluated a large number of times (by default \(100\)), calculating an assembly ratio. If the ratio is \(1\), the rule is considered bounded and deterministic and, as such, a valid solution.


\section{Finding the minimal assembly rule}

By iteratively ruling out lower values of \(\widetilde{K}_s\) and \(\widetilde{K}_c\), a minimal solution can be found, as detailed in Figure~\ref{fig:sat_alg}. It is also possible to generate and compare alternative solutions of varying complexity. While forbidding an undefined solution and retrying couldm in principle, continue until the computer runs out of memory (or the solution is disproven or valid), the results presented below used a limit of 100 retries before moving on.

The exploration of the solution landscape can also be done in parallel, with each combination of \(\widetilde{K}_s\) and \(\widetilde{K}_c\) explored concurrently.

\begin{figure}
    \centering
    \resizebox{\textwidth}{!}{\input{figures/SAT_flow}}
    \caption{Algorithm for finding the minimal solution using SAT. Even if a solution is found to be satisfiable it might not assemble correctly every time. Additional solutions for a given \(\widetilde{K}_c\) and \(\widetilde{K}_s\) are found by explicitly forbidding the current solution. Alternatively, it is possible to use a solver like relsat to obtain multiple solutions. }
    \label{fig:sat_alg}
\end{figure}

\section{Simplification by substitution}
\label{sec:substitution_solving}
An alternative and complementary approach is to substitute species that are similar, removing duplicates. Starting from a fully addressable solution, any pair of species \(s_1\) and \(s_2\) with the same configuration of patches are tested. If we can remove \(s_1\) and replace the patches complementary to it with ones complementary to the patches of \(s_2\) and still get the correct output shape, we have successfully simplified the rule. This substitution continues until all species pairs have been tried.

\section{Example solves}
\label{sec:example_solves}
This section presents a set of different shapes solved to demonstrate the SAT solver method described above.

\paragraph{Swan} A more sophicticated version of the ``giraffe duck'' from Figure~\ref{fig:UND}, the Swan shape has a fixed neck length of one intermediate cube, as shown in Figure~\ref{fig:swan}.a). Figure~\ref{fig:swan}.b) shows the solution landscape, where valid deterministic solutions can be found along the upper diagonal. Many of the undefined (UND) configurations still assemble at a high ratio, indicating that these \(\widetilde{K}_s\), \(\widetilde{K}_c\) combinations still could provide useful solutions.

\begin{figure}[h]
    \centering
    %\includesvg[width=0.6\textwidth, inkscapelatex=false]{figures/solve/swan.svg}
    \begin{overpic}[width=\textwidth]{figures/solve/swan.eps}
        \put(10,450){a)}
        \put(360,450){b)}

        \put(380, 260){\makebox(0,0){\rotatebox{90}{Number of colours (\(\widetilde{K}_c\))}}}
        \put(490, 0){Number of species (\(\widetilde{K}_s\))}
    \end{overpic}
    \caption{Finding assembly rules for a polycube ``Swan''. \textbf{a)} Visualisation of the swan shape. \textbf{b)} Solution landscape.}
    \label{fig:swan}
\end{figure}

\paragraph{Polyomino J} With the 2D option enabled, the solver requires fewer clauses as it only needs to check four patches and four rotations per particle. Here this is used to expore the solution landscape for a polyomino shaped as the letter \textbf{J}, shown in Figure~\ref{fig:letter_J}.a). Figure~\ref{fig:letter_J}.b) shows the resulting solution landscape, where the minimal solution is just one species less than the fully adressable one. This can be explained by the lack of symmetry and modularity in the shape, where only the species used for the ``endpoints'' can be reused. 

\begin{figure}[h]
    \centering
    %\includesvg[width=0.6\textwidth, inkscapelatex=false]{figures/solve/letter_J.svg}
    \begin{overpic}[width=\textwidth]{figures/solve/letter_J.eps}
        \put(10,480){a)}
        \put(300,480){b)}

        \put(300, 260){\makebox(0,0){\rotatebox{90}{Number of colours (\(\widetilde{K}_c\))}}}
        \put(460, 0){Number of species (\(\widetilde{K}_s\))}
    \end{overpic}
    \caption{Finding assembly rules for a polyomino ``letter J''. \textbf{a)} Visualisation of the shape. \textbf{b)} Solution landscape.}
    \label{fig:letter_J}
\end{figure}

\paragraph{Robot} The ``robot'' shape seen in Figure~\ref{fig:robot}.a) consists of more cubes than the previous examples, thereby resulting in the larger assembly landscape seen in Figure~\ref{fig:robot}.b). Once again, the valid solutions clearly follow the border region between the blue UND region of solutions with varying assembly ratio and the red region where no solution is possible.

\begin{figure}[h]
    \centering
    %\includesvg[width=0.8\textwidth, inkscapelatex=true]{figures/solve/robot.svg}
    \begin{overpic}[width=\textwidth]{figures/solve/robot.eps}
        \put(10,480){a)}
        \put(360,480){b)}

        \put(380, 260){\makebox(0,0){\rotatebox{90}{Number of colours (\(\widetilde{K}_c\))}}}
        \put(530, -10){Number of species (\(\widetilde{K}_s\))}
    \end{overpic}
    \caption{Finding assembly rules for a polycube ``robot''. \textbf{a)} Visualisation of the robot shape. \textbf{b)} Solution landscape.}
    \label{fig:robot}
\end{figure}

\paragraph{Hollow cube} The hollow \(3 \times 3 \times 3\) cube (Figure~\ref{fig:hollow_cube}.a) is a good example of a larger structure (20 cubes) that still has a very low complexity solution, as seen in Figure~\ref{fig:hollow_cube},b). This can be explained by the large amount of symmetry found in the shape, needing just a single species for the vertices and another species for the edges.

\begin{figure}[h]
    \centering
    %\includesvg[width=\textwidth, inkscapelatex=false]{figures/solve/cube.svg}
    \begin{overpic}[width=\textwidth]{figures/solve/cube.eps}
        \put(10,480){a)}
        \put(320,600){b)}

        \put(350, 310){\makebox(0,0){\rotatebox{90}{Number of colours (\(\widetilde{K}_c\))}}}
        \put(520, -10){Number of species (\(\widetilde{K}_s\))}
    \end{overpic}
    \caption{Finding assembly rules for a hollow \(3 \times 3 \times 3\) cube. \textbf{a)} Visualisation of the \(3 \times 3 \times 3\) cube shape. \textbf{b)} Solution landscape.}
    \label{fig:hollow_cube}
\end{figure}

\paragraph{Solid cube} Figure~\ref{fig:solid_cube} shows the solution landscape for a solid \(3 \times 3 \times 3\) cube. While it is visible also for the hollow cube, the sharp border of valid solutions along the diagonal seen in previous solutions is now less clear. This could be due to an increasing number of altarnative solutions available for a given \(\widetilde{K}_s\), \(\widetilde{K}_c\) position, leading to some positions getting classified as UND while a valid solution could be found through further retries.

\begin{figure}[h]
    \centering
    %\includesvg[width=\textwidth, inkscapelatex=false]{figures/solve/filled_cube.svg}
    \begin{overpic}[width=\textwidth]{figures/solve/filled_cube.eps}
        \put(10,480){a)}
        \put(300,600){b)}

        \put(300, 320){\makebox(0,0){\rotatebox{90}{Number of colours (\(\widetilde{K}_c\))}}}
        \put(510, -10){Number of species (\(\widetilde{K}_s\))}
    \end{overpic}
    \caption{Finding assembly rules for a solid \(3 \times 3 \times 3\) cube. \textbf{a)} Visualisation of the \(3 \times 3 \times 3\) cube shape. \textbf{b)} Solution landscape.}
    \label{fig:solid_cube}
\end{figure}


\section{Patchy particle simulation}
While the stochastic assembler works well to test determinism, a more realistic assembly can be achieved through patchy particle simulation, as introduced in Section~\ref{sec:patchy_particles}.

The oxDNA patchy particle simulator used is a version with torsional interaction enabled, as detailed in Section~\ref{sec:appendix_patchy}. Since there are different \emph{narrow types} available, corresponding to slightly different patch interaction potential widths, we start by simulating the structure stability for each potential and for a range of different temperatures. As seen in Figure~\ref{fig:narrow_types}, higher temperatures and lower narrow types cause the assembly to fall apart and the potential energy to increase. For narrow type 0, there is still some connectivity for the higher temperatures, with the energy occilating as particles bind and unbind, but for higher narrow types the occilations grow less and the particles remain unbound.

\begin{figure}[h]
    \centering
    \begin{overpic}[width=\textwidth]{figures/patchysim/narrow_types.eps}
        \put(-10,210){a)}
        \put(210,210){b)}
    \end{overpic}
    \caption{Simulation of a pre-assembled patchy particle cube. \textbf{a)} The minimal solution to the hollow \(3 \times 3 \times 3\) from Figure~\ref{fig:hollow_cube}. \textbf{b)} Potential energy over time for different narrow types and temperatures.}
    \label{fig:narrow_types}
\end{figure}


Next, we then try to simulate and compare the assemblies of the fully addressable and minimal solutions to the shapes introduced in Section~\ref{sec:example_solves}. All the following simulations are run with narrow type 0.

Looking at Figure~\ref{fig:patchy_energy}, there are temperatures for which each of the shapes start to nucleate early on, as a sudden drop in the energy over time corresponds to a nucleation event.

\begin{figure}[h]
    \centering\includesvg[width=\textwidth, inkscapelatex=false]{figures/patchysim/energy.svg}
    \caption{Potential energy over time in patchy particle simulations. The top row shows the fully adressable solution while the bottom row is the minimal solution found. Each simulation is done using the narrow type \(0\) potential at a \(0.1\) particle density.}
    \label{fig:patchy_energy}
\end{figure}

Another measure is the size of the clusters in the system, where a cluster is a set of particles joined through their patches. In Figure~\ref{fig:max_cluster}, we measure the normalised size of the largest cluster found, where 100 per cent is the intended size of the polycube. 

While the other shapes do not assemble any larger than the intended size, the two cubes aggregate into clusters many times larger than intended. \emph{This happens because these shapes are self-limiting through their geometry, which works less well on flexible patchy particles compared to the rigid lattice of the stochastic assembler}. In contrast, the other shapes are self-limiting through their topology, with no loops in their connectivity graphs.

\begin{figure}[h]
    \centering\includesvg[width=\textwidth, inkscapelatex=false]{figures/patchysim/largest_cluster_size.svg}
    \caption{Largest cluster size over time for patchy particle simulations. The top row shows the fully adressable solution while the bottom row is the minimal solution found. Each simulation is done using the narrow type \(0\) potential at a \(0.1\) particle density.}
    \label{fig:max_cluster}
\end{figure}

We can also look at the assembly yield, shown in Figure~\ref{fig:complete_clusters} as the percentage of clusters having the correct number of each species. Despite the aggregation previously discussed, the two cube shapes have a growing number of correct assemblies for certain temperatures. Meanwhile, the other shapes are all approach a high assemblly yield for lower temperatures.

\begin{figure}[h]
    \centering\includesvg[width=\textwidth, inkscapelatex=false]{figures/patchysim/complete_clusters.svg}
    \caption{Assembly yield over time for patchy particle simulations. The top row shows the fully adressable solution while the bottom row is the minimal solution found.Each simulation is done using the narrow type \(0\) potential at a \(0.1\) particle density.}
    \label{fig:complete_clusters}
\end{figure}

A general remark on the simulation results in Figure~\ref{fig:patchy_energy}, \ref{fig:max_cluster}, and~\ref{fig:complete_clusters} is that there is usually not any significant difference between the assembly results for the fully adressable solution (top row) and the minimal solution (bottom row). This means that experimental applications could get away with using significantly less unique building blocks, saving both money and time.

\section{Multifarious assemblies}

Another feature with the SAT solver approach is the ability to design \emph{multifarious} assemblies, that is, rules that can assemble into more than one shape. This is simply done by defining multiple distinct shapes next to each other as input to the solver.

Figure~\ref{fig:multifarious_rectangles} shows a solution landscape for two different rectangle shapes. The fully adressable solution (in the upper-right corner) has no shared species between the two shapes, while a simpler solution, such as: \href{https://akodiat.github.io/polycubes/?assemblyMode=stochastic&rule=0d01860000000501860000000905020000008d0102880000}{0d0186000000\allowbreak050186000000\allowbreak090502000000\allowbreak8d0102880000}
with \(\widetilde{K}_s=4\), \(\widetilde{K}_c=3\), share three out of four species.

\begin{figure}[h]
    \centering\includesvg[width=\textwidth, inkscapelatex=false]{figures/solve/2rect.svg}
    \caption{Multifarious assembly of rectangles. Solution landscape (right) for the assembly of two different rectangular shapes (left).}
    \label{fig:multifarious_rectangles}
\end{figure}