\begin{savequote}[8cm]
Far out in the uncharted backwaters of the unfashionable end of the western spiral arm of the Galaxy lies a small unregarded yellow sun. Orbiting this at a distance of roughly ninety-two million miles is an utterly insignificant little blue green planet whose ape-descended life forms are so amazingly primitive that they still think digital watches are a pretty neat idea.
  \qauthor{--- D. Adams, The Hitchhiker's Guide to the Galaxy}
\end{savequote}

\chapter{Introduction}\label{ch:1-intro}

\minitoc

How do you design and assemble something on the nanoscale? Imagine building something with lego bricks; you choose the building blocks you want and use your hands to attach them where you want them to be. However, for nanoscale objects, it is difficult to have that level of top-down control. Instead, more success has been had by imitating nature and letting the building blocks assemble themselves. This thesis will cover novel methods and tools to design such self-assembling nanostructures.

\section{Thesis structure}
This thesis covers two related projects, both concerning the design and modular self-assembly of nanostructures. Each project is introduced by a separate chapter on its relevant history and background.

The first project, introduced by Chapter~\ref{ch:polycubes_intro}, covers an abstract self-assembly model called \emph{polycubes}. Chapter~\ref{ch:polycubes1} details the model and the shapes we get when randomly sampling the input space. Chapter~\ref{ch:polycubes2} presents the results on the reverse problem; given a polycube shape, what input rules will assemble it and what is the least complex input you can find?

The second project takes a more detailed view of self-assembly design, with Chapter~\ref{ch:oxview_intro} introducing computer-aided design tools for nucleic acid structures, together with some related simulation models. Chapter~\ref{ch:oxview} then presents my contributions to \emph{oxView}, a web-based tool for the visualisation, design, and integration of DNA, RNA and protein structures.

Before moving on to the separate projects, however, the following sections will provide a general background on nucleic acid self-assembly and complexity.

%\section{Scope of the thesis}


\section{DNA design}
Deoxyribonucleic acid (DNA) is a string-like molecule used to encode the genes of living systems \cite{calladine1997understanding}. These strands of DNA are made up of units called \emph{nucleotides}, consisting of a sugar-phosphate backbone as well as one of four possible bases: \emph{adenine} (\textbf{A}), \emph{thymine} (\textbf{T}) \emph{cytosine} (\textbf{C}), and \emph{guanine} (\textbf{G}).

Through Watson-Crick base-pairing, the \textbf{A} nucleotide form two hydrogen bonds with \textbf{T}, while \textbf{G} forms three with \textbf{C}, making DNA double-stranded. Each strand has a directionality, conventionally represented as going from the 3' to the 5' end of the strand, making the duplex \emph{anti-parallel}.

The base part of the nucleotide is \emph{hydrophobic}, while the sugar-phosphate backbone is \emph{hydrophilic}, which means that the bases ``hide'' on the inside of the duplex to avoid contact with water molecules. However, the backbone distance is about 6 Å (0.6 nm), while the bases would need to be at a distance of 3.3 Å (the thickness of the base) to not leave any room for water \cite{calladine1997understanding}. To solve this, the DNA duplex forms a double-helix structure with a radius of about 9 Å, placing everything at an energetically comfortable distance.

While a single double-helix is the most natural confirmation, it is possible for strands to branch into multiple junctions. For example, the Holliday junction is a junction between four double-helical arms, shown in Figure~\ref{fig:holliday} in one of its possible configurations.

\begin{figure}
    \centering\includegraphics[width=\textwidth]{figures/holliday.png}
    \caption{Holliday junction, designed in oxView. Cones at the end indicates the 3' end of each of the four strands.}
    \label{fig:holliday}
\end{figure}

%https://www.rcsb.org/structure/1M6G

%Double-stranded DNA has a persistence length of approximately [], while single-stranded sections are much more flexible,

By designing sequences with complementary domains for the intended duplex regions, it is possible to create many different DNA motifs and structures \cite{seeman_2016, Seeman1982}, an understanding that pioneered the field of structural DNA nanotechnology.

%% Add more here

Another breakthrough in the field was the DNA origami technique \cite{rothemund2006folding} a now popular and proven method for creating larger irregular structures using DNA. The principle behind it, as illustrated in Figure~\ref{fig:dnaOrigami}, is to use short staple strands to fold one long viral scaffold strand into the desired structure.

\begin{figure}
    \centering\includegraphics[width=\textwidth/5]{figures/melt/melted.png}\hfill
%    \centering\includegraphics[width=\textwidth/5]{figures/melt/intermediate2.png}\hfill
    \centering\includegraphics[width=\textwidth/3]{figures/melt/intermediate1.png}\hfill
    \centering\includegraphics[width=\textwidth/3]{figures/melt/assembled.png}
    \caption{Illustration of DNA origami self-assembly of a tetrahedron. A long scaffold strand (purple), obtained from a virus, is folded into the desired shape by multiple short staple strands binding to complementary domains of the scaffold. Tetrahedron design obtained from \url{https://cando-dna-origami.org/examples/} and melted using oxDNA simulation \cite{ouldridge2010dna}.
    }
    \label{fig:dnaOrigami}
\end{figure}

Using design tools such as caDNAno \cite{cadnano}, it has become relatively easy to design structures of any given form. See Section~\ref{sec:design_tools} for an introduction to additional such tools.

In DNA origami, the size of the structure is limited by the length of the scaffold, which motivates researchers to investigate modular approaches. Some previous results will be described in Section~\ref{sec:experimental_appl}, but the results of this thesis aim to simplify the design process significantly.

\section{RNA design}
\label{sec:RNA_design}
Another promising building material for self-assembly is ribonucleic acid (RNA). RNA is very similar to DNA, but with the \emph{thymine} base (\textbf{T}) replaced by \emph{uracil} (\textbf{U}).

Biologically, DNA is transcribed into RNA by the RNA polymerase enzyme as part of gene expression. While DNA folding is easier to predict, the fact that RNA is more reactive than DNA also offers the possibility of a more useful structure; for example, by incorporating aptamers, enzymes, and other such functionalities \cite{guo2010emerging}.

In 2014, Geary et al., from the Andersen lab in Aarhus, demonstrated a method \cite{geary2014single, sparvath2017computer, geary2021rna} for co-transcriptionally folded RNA origami, which also enables folding \emph{in vivo}. As shown in Figure~\ref{fig:rna_origami}, the design used a set of tertiary RNA motifs (such as kissing hairpins and double crossovers) as modules. These modules are then combined into a single-stranded blueprint, for which a sequence that should co-transcriptionally fold into the intended shape is found. 

\begin{figure}[h]
  \centering
  \begin{overpic}[width=\textwidth]{figures/rna_origami.png}
      \put(0,600){a)}
      \put(0,250){b)}
      \put(0,110){c)}
      \put(510,600){d)}
      \put(510,430){e)}
      \put(510,310){f)}
      \put(510,150){g)}
  \end{overpic}
  \caption{Co-transcriptional folding of RNA origami, adapted from \cite{geary2021rna}. a) The set of RNA motifs used as modular building blocks. b) Schematic of the modules connected to form a single strand. c) Atomistic model of the design in b). d) Shows the text-based blueprint used to create designs, while e), f), and g) shows scripts developed to aid the visualisation and preform sequence design for the origami.}
  \label{fig:rna_origami}
\end{figure}

The Andersen lab is one of the partners to the ITN network I am part of, and I have spent a two-month secondment there working with their RNA origami method. Some of my results on simulating RNA designs are covered in Section~\ref{sec:converting_rna_origami}.

% "The emerging field of RNA nanotechnology121 might seem more promising in this regard because RNA is readily transcribed into a single strand in cells, which can be directly folded into a programmed nanostructure"
% https://www.nature.com/articles/nnano.2011.187

\section{Algorithmic Information Theory and input-output maps}
\label{sec:AIT}
% https://www.ox.ac.uk/news/science-blog/%E2%80%98simplicity-bias%E2%80%99-science

% https://www.nature.com/articles/s41467-018-03101-6

% https://solo.bodleian.ox.ac.uk/permalink/f/89vilt/oxfaleph022417805

%Some things, whether in the form of a shape, a song, or a binary string, require less information to describe than others.

Besides possible self-assembly materials, another important concept in this thesis is the notion of \emph{complexity}. Complexity has different definitions in different fields, but an intuitive version is the amount of information needed to describe something. Some things, whether in the form of a shape, a song, or a binary string, require less information to describe than others. We would then call those less complex than their counterparts.

Let think of the complexity of text strings. If you have a monkey pressing random keys on a typewriter, you would expect it to produce every string of length \(N\) with equal probability (assuming the keystrokes were indeed truly random). With \(k\) keys on the keyboard, the probability for any string of length \(N\) is then \(k^{-N}\). For example, the title of this thesis, while unlikely to appear randomly, would be equally as probable as any other 50-character string, see the three example strings below:
\begin{lstlisting}[numbers=left]
  DESIGN AND MODULAR SELF-ASSEMBLY OF NANOSTRUCTURES
  SHWDRVWKFORWJDOEXOZLSBNREKC Z  VSDJJF  ROKFYRVMIUI
  AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
\end{lstlisting}

But what if we described our strings using algorithms, rather than a full listing of the letters it contains? For example, string number three above could be described using the C programming language as:

\begin{lstlisting}[language=c]
printf("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");
\end{lstlisting}

But a much shorter description can be found as follows:

\begin{lstlisting}[language=c]
for(int i=50; i--;) printf("A");
\end{lstlisting}

There are also a number of possible valid variations of the code above, with different variable names and coding conventions, all producing the same output. In other words, not only is the description shorter than writing out the full string but multiple inputs map to the same output, increasing the probability of the output further.

This concept of using the shortest possible computer program that can describe an object (for example, a binary string) to determine its complexity is central within the field of Algorithmic Information Theory (AIT) and is called \emph{Kolmogorov complexity} (or Solomonoff–Kolmogorov–Chaitin to give full credit) \cite{LiMing2019AitK}. More specifically, the Kolmogorov complexity \(K(x)\) of an output \(x\) is the length of the shortest program that generates \(x\) on a Universal Turing Machine (UTM).

AIT also includes the \emph{coding theorem}, introducing lower and upper bounds for the probability \(P(x)\) of generating a binary string \(x\) as \(2^{-K(x)} \le P(x) \le 2^{-K(x) + \mathcal{O} (1)}\). In other words, low-complexity outputs are exponentially more likely to be generated by random input compared to high-complexity outputs. This could be compared to how, there are many more programs generating the ``simple'' string number 3 above compared to the randomly generated string 2 or the carefully selected string 1.

However, a problem with Komologrov complexity is that finding the shortest program for a given output is far from trivial (it is, in fact, \emph{uncomputable} in general, due to the \emph{halting problem}). Fortunately, Dingle at al \cite{dingle2018input} were able to derive an upper bound to the probability using a computable approximation \(\widetilde{K}(x)\) of the Komologrov complexity:

\[
  P(x) \lesssim 2^{-a\widetilde{K}(x) -b}
\]

where \(a\) and \(b\) are constants that depend on the input-output map used (but are independent of \(x\)). This is very helpful for calculating the complexity of self-assembled shapes, where properties of the simplest known input rule can be used as such a Komologrov complexity proxy, as  will be seen in Section~\ref{sec:polyomino} and Chapter~\ref{ch:polycubes1}.




