%\begin{savequote}[8cm]
%\textlatin{Cor animalium, fundamentum e\longs t vitÃ¦, princeps omnium, Microco\longs mi Sol, a quo omnis vegetatio dependet, vigor omnis \& robur emanat.}

%The heart of animals is the foundation of their life, the sovereign of everything within them, the sun of their microcosm, that upon which all growth depends, from which all power proceeds.
  %\qauthor{--- William Harvey \cite{harvey_exercitatio_1628}}
%\end{savequote}

\chapter{The polycube codebase}
\label{ch:appendix_polycubes}

\minitoc

The code used for polycube assembly can be found at \url{https://github.com/akodiat/polycubes}. This code repository contains both the stochastic assembly code and the SAT solver code, as detailed in the sections below.

\section{Stochastic assembly code}
The polycube assembly model was implemented in both C++ and JavaScript. The C++ implementation enables the fast command--line evaluation of input rules required for the sampling performed in Chapter~\ref{ch:polycubes1}. Meanwhile, the JavaScript implementation makes it possible to assemble and visualise polycubes in a web browser, which was useful for both model validation and for public outreach activities.

In order to speedup sampling, the c++ binary can be called multiple times in parallel and merged with the merge python script. For the results covered in Chapter~\ref{ch:polycubes1}, the sampling was done on 100 concurrent nodes and merged.

The largest sampling done, the polyomino reference with 1e9 samples (described in Section~\ref{sec:refcalc}), took a total of 72 hours, 57 minutes, and 58 seconds to sample with 100 copies each performing 1e7 samples in parallel. The merging script then took another 197 hours, 40 minutes, and 24 seconds to run, but it clearly saved a significant amount of time compared to running a single sampling for 100 times longer (which would take almost 7300 hours or 304 days).

Finally the analysis script took another 301 hours, 44 minutes, and 17 seconds to run.

%took 359 hours, 9 minutes, and 44 seconds

\subsection{C++}
The stochastic assembly C++ code is found in the \texttt{cpp} directory. The Eigen and HDF5 libraries are required to compile the c++ binary. The python binding requires Eigen and the pybind library.

Install dependencies:
\begin{lstlisting}[language=bash]
  conda install -c conda-forge pybind11 eigen

  wget https://www.hdfql.com/releases/2.3.0/HDFql-2.3.0_Linux64_GCC-4.9.zip
  unzip HDFql-2.3.0_Linux64_GCC-4.9.zip
  mv hdfql-2.3.0 ~
\end{lstlisting}

The cmake specification at \texttt{cpp/src/CMakeLists.txt} is configured to search for HDFql at the path \texttt{\textasciitilde/hdfql-2.3.0}, so make sure to update the file if you install another version of HDFql or if it is installed at another path.

Build the polycube binary with cmake:
\begin{lstlisting}[language=bash]
  mkdir build && cd build
  cmake -DCMAKE_C_COMPILER=gcc -DCMAKE_CXX_COMPILER=g++ ..
  make
\end{lstlisting}

You should find the binary in the root of this directory (cpp)

Run ./polycubes --help for more info

\subsection{Python binding and analysis}
The C++ binary is used to sample the input rule space, as done in Chapter~\ref{ch:polycubes1}. However, to evaluate individual rules and access the stochastic assembly model through python, you can compile a pybind11 (\url{https://github.com/pybind/pybind11}) library that can be imported into python. There are build scripts and examples for both the python analysis scripts and the SAT solver code:

\begin{lstlisting}[language=bash]
  cd py
  bash build_pybind.sh
\end{lstlisting}

\begin{lstlisting}[language=bash]
  cd solve/py
  bash build_polycube_pybind.sh
\end{lstlisting}

This will generate a shared module \texttt{libpolycubes.so}

\begin{lstlisting}[language=python]
  import libpolycubes as pl
  pl.getCoords("040087000000")
\end{lstlisting}

The \texttt{py} directory contains a set of analysis scripts to interpret the results of the C++ binary output.

\subsection{JavaScript}
The JavaScript assembler is found in the \texttt{js} directory, with HTML files in the root of the repository. To run, you can either start a local webserver with the repository content or open the \texttt{index.html} file directly. You can also access the GitHub site at \url{https://akodiat.github.io/polycubes}.

The 3D visualisation is done with the help of the Three.js library (\url{https://threejs.org/}).

Polycube rules formatted as either decimal or hexadecimal strings (Section~\ref{sec:string_repr}) can be supplied to the assembler as URL arguments, for example: \url{akodiat.github.io/polycubes?decRule=|2:2|1:3||-3:0|_-1:1|-2:3||||_||||3:1|} and \url{akodiat.github.io/polycubes?rule=000a07008c00858b00000000000000000d00}.

\subsubsection{Patchy sphere preview}

Use the following script to generate patchy sphere preview images
\begin{lstlisting}[language=JavaScript]
  // Change cubes to spheres
  system.changeToSpheres()

  // Position camera (to get the same view angle)
  camera.position.copy(new THREE.Vector3(4,4,6).add(system.centerOfMass))
  camera.lookAt(system.centerOfMass)
  render()

  // Save image
  saveCanvasImage()
\end{lstlisting}

By default, the colours of species and patches only vary in hue. They can be made more diverse by also varying their saturation and luminosity:
\begin{lstlisting}[language=JavaScript]
system.particleMaterials.forEach(m=>{m.color.offsetHSL(0, 0.5*(Math.random()-0.5), 0.5*(Math.random()-0.5))})
system.colorMaterials.forEach(m=>{m.color.offsetHSL(0, 0.5*(Math.random()-0.5), 0.5*(Math.random()-0.5))})
\end{lstlisting}


\section{Polycube solver}

The polycube SAT solver code is found in the \texttt{solve} directory. As for the stochastic assembly code, the SAT solver has multiple implementation. The main implementation is done in Python and can be used for production runs. The other implementation is in JavaScript and is used to draw shape specifications and to solve smaller shapes.

\subsection{Python}

To use the python solver, you need to install the python-sat library:

\begin{lstlisting}[language=bash]
  python -m pip install python-sat[pblib,aiger]
\end{lstlisting}

To verify that the solver output assembles correctly, you also need to compile the polycube python binding:

\begin{lstlisting}[language=bash]
  cd solve/py
  bash build_polycube_pybind.sh
\end{lstlisting}

Finally, to solve a shape for a given number of species and colours, you call the \texttt{solve.py} script with the desired parameters:

\begin{lstlisting}[language=bash]
  python solve.py ../shapes/[shape].json [nSpecies] [nColors]
\end{lstlisting}

There are also ``multi--solve'' scripts to automatically create jobs solving all possible combinations of species and colour counts.

As an example of custom scripting, it is also possible to extract the CNF clauses to a file:

\begin{lstlisting}[language=python]
  import utils
  import json
  from polycubeSolver import polysat

  def saveClauses(nCubeTypes, nColors, solveSpecPath):
      with open(solveSpecPath, "r") as f:
          data = f.read()
      solveSpec = json.loads(data)

      mysat = polysat(
          solveSpec["bindings"],
          nCubeTypes,
          nColors,
          solveSpec["nDim"],
          solveSpec["torsion"]
      )

      name = solveSpecPath.split("/")[-1].split(".")[0]
      outPath = "{}t_{}c_{}.cnf".format(
          nCubeTypes, nColors, name
      )
      mysat.dump_cnf_to_file(outPath)

      print("Saved to {}".format(outPath))

  saveClauses(6, 9, "../shapes/scaling/cube4.json")
\end{lstlisting}

\subsection{JavaScript}
 The JavaScript implementation of the polycube solver is found in the \texttt{solve/js} directory, with the  HTML index file at \texttt{solve/index.html} directory. To use, you can either start a local webserver with the complete repository content and navigate to \url{http://localhost:8080/solve/index.html}, or access the GitHub site at \url{https://akodiat.github.io/polycubes/solve}.

 The web app provides an interface where you can interactively draw polycube shapes and save them as JSON shapes for the Polycube SAT solver. You can also use the console commands \texttt{drawFromCoords}, \texttt{drawSolidBlock}, and \texttt{drawSolidCube} to create shapes.

 You can also click a button to attempt to solve the shape within the browser. This is, however, usually only feasible for small shapes using SAT, so a substitution simplifier is also employed to work towards a minimal solution by substituting similar species in the fully addressable solution.


\subsection{Patchy particle code}
\label{sec:appendix_patchy}
The modified version of oxDNA used to simulate torsional patchy particles can be found at \url{https://github.com/Akodiat/oxDNA_torsion}. To download and combile, run:

\begin{lstlisting}[language=bash]
  git clone https://github.com/Akodiat/oxDNA_torsion.git
  cd oxDNA_torsion
  mkdir build
  cd build
  cmake ..
  make -j4
  make romano
\end{lstlisting}

Simulation files for a given polycube shape can then be generated through the web console at \url{https://akodiat.github.io/polycubes}, by running:

\begin{lstlisting}[language=JavaScript]
  getPatchySimFiles(
    "070000070500868700000000", // Rule string
    1, // Number of assemblies
    "cube", // Name
    "/users/joakim/repo/oxDNA_torsion", // Path to oxDNA directory
    [.01,.02,.03,.04,.05,.06,.07,.08,.09,.1], // Temperature range
    0.1 // Density (used to generate configuration when the number
    // of assemblies is more than one)
  )
\end{lstlisting}

If the number of assemblies is one, a configuration file will be generated specifying the assembled shape. Else, the \texttt{generateConf.sh} script can be used to generate a random configuration with the provided density.


\chapter{The oxView codebase}

The code for oxView can be found at \url{https://github.com/sulcgroup/oxdna-viewer}. It is written in TypeScript and compiled into JavaScript. The 3D visualisation is done with the help of the Three.js library (\url{https://threejs.org/}), while the graphical user interface uses the Metro 4 library (\url{https://metroui.org.ua/}). 

If you make any changes, you need both TypeScript (\url{https://www.typescriptlang.org/}) and Node.js (\url{https://nodejs.org/}) installed to compile. Typing \verb|npm install| in the source directory should install all required node modules. Then type \verb|tsc| to compile the typescript into javascript. 

More detailed documentation can be found in the README.md file in the repository: \url{https://github.com/sulcgroup/oxdna-viewer/blob/master/README.md}

\minitoc

